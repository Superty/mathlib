/-
Copyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kyt√∂l√§
-/
import topology.continuous_function.bounded

/-!
# Thickenings and thickened indicators

## Main definitions

## Main results

-/
noncomputable theory
open_locale classical nnreal ennreal topological_space bounded_continuous_function

open nnreal ennreal set metric emetric filter

lemma _root_.ennreal.div_le_div {a b c d : ‚Ñù‚â•0‚àû} (hab : a ‚â§ b) (hdc : d ‚â§ c) :
  a / c ‚â§ b / d :=
begin
  rw [div_eq_mul_inv, div_eq_mul_inv],
  apply ennreal.mul_le_mul hab (ennreal.inv_le_inv.mpr hdc),
end

section thickened_indicator

variables {Œ± : Type*} [pseudo_emetric_space Œ±]

/-- The `Œ¥`-thickened indicator of a set `E` is the function that equals `1` on `E`
and `0` outside a `Œ¥`-thickening of `E` and interpolates (continuously) between
these values using `inf_edist _ E`.

`thickened_indicator_aux` is the unbundled `‚Ñù‚â•0‚àû`-valued function. See `thickened_indicator`
for the (bundled) bounded continuous function with `‚Ñù‚â•0`-values. -/
def thickened_indicator_aux (Œ¥ : ‚Ñù) (E : set Œ±) : Œ± ‚Üí ‚Ñù‚â•0‚àû :=
Œª (x : Œ±), (1 : ‚Ñù‚â•0‚àû) - (inf_edist x E) / (ennreal.of_real Œ¥)

lemma continuous_thickened_indicator_aux {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) :
  continuous (thickened_indicator_aux Œ¥ E) :=
begin
  unfold thickened_indicator_aux,
  let f := Œª (x : Œ±), (‚ü®1, (inf_edist x E) / (ennreal.of_real Œ¥)‚ü© : ‚Ñù‚â•0 √ó ‚Ñù‚â•0‚àû),
  let sub := Œª (p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0‚àû), ((p.1 : ‚Ñù‚â•0‚àû) - p.2),
  rw (show (Œª (x : Œ±), ((1 : ‚Ñù‚â•0‚àû)) - (inf_edist x E) / (ennreal.of_real Œ¥)) = sub ‚àò f, by refl),
  apply continuous.comp (@ennreal.continuous_nnreal_sub 1),
  apply (ennreal.continuous_div_const (ennreal.of_real Œ¥) _).comp continuous_inf_edist,
  norm_num [Œ¥_pos],
end

lemma thickened_indicator_aux_le_one (Œ¥ : ‚Ñù) (E : set Œ±) (x : Œ±) :
  thickened_indicator_aux Œ¥ E x ‚â§ 1 :=
by apply @tsub_le_self _ _ _ _ (1 : ‚Ñù‚â•0‚àû)

lemma thickened_indicator_aux_lt_top {Œ¥ : ‚Ñù} {E : set Œ±} {x : Œ±} :
  thickened_indicator_aux Œ¥ E x < ‚àû :=
lt_of_le_of_lt (thickened_indicator_aux_le_one _ _ _) one_lt_top

lemma thickened_indicator_aux_closure_eq (Œ¥ : ‚Ñù) (E : set Œ±) :
  thickened_indicator_aux Œ¥ (closure E) = thickened_indicator_aux Œ¥ E :=
by simp_rw [thickened_indicator_aux, inf_edist_closure]

lemma thickened_indicator_aux_one (Œ¥ : ‚Ñù) (E : set Œ±) {x : Œ±} (x_in_E : x ‚àà E) :
  thickened_indicator_aux Œ¥ E x = 1 :=
by simp [thickened_indicator_aux, inf_edist_zero_of_mem x_in_E, tsub_zero]

lemma thickened_indicator_aux_one_of_mem_closure
  (Œ¥ : ‚Ñù) (E : set Œ±) {x : Œ±} (x_mem : x ‚àà closure E) :
  thickened_indicator_aux Œ¥ E x = 1 :=
by rw [‚Üêthickened_indicator_aux_closure_eq, thickened_indicator_aux_one Œ¥ (closure E) x_mem]

lemma thickened_indicator_aux_zero
  {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) {x : Œ±} (x_out : x ‚àâ thickening Œ¥ E) :
  thickened_indicator_aux Œ¥ E x = 0 :=
begin
  rw [thickening, mem_set_of_eq, not_lt] at x_out,
  unfold thickened_indicator_aux,
  apply le_antisymm _ bot_le,
  have key := tsub_le_tsub (@rfl _ (1 : ‚Ñù‚â•0‚àû)).le (ennreal.div_le_div x_out rfl.le),
  rw [ennreal.div_self (ne_of_gt (ennreal.of_real_pos.mpr Œ¥_pos)) of_real_ne_top] at key,
  simpa using key,
end

lemma thickened_indicator_aux_mono {Œ¥‚ÇÅ Œ¥‚ÇÇ : ‚Ñù} (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : set Œ±) :
  thickened_indicator_aux Œ¥‚ÇÅ E ‚â§ thickened_indicator_aux Œ¥‚ÇÇ E :=
begin
  intro x,
  apply tsub_le_tsub (@rfl ‚Ñù‚â•0‚àû 1).le,
  exact ennreal.div_le_div rfl.le (of_real_le_of_real hle),
end

lemma thickened_indicator_aux_subset (Œ¥ : ‚Ñù) {E‚ÇÅ E‚ÇÇ : set Œ±} (subset : E‚ÇÅ ‚äÜ E‚ÇÇ) :
  thickened_indicator_aux Œ¥ E‚ÇÅ ‚â§ thickened_indicator_aux Œ¥ E‚ÇÇ :=
begin
  intro x,
  apply tsub_le_tsub (@rfl ‚Ñù‚â•0‚àû 1).le,
  exact ennreal.div_le_div (inf_edist_le_inf_edist_of_subset subset) rfl.le,
end

lemma thickened_indicator_aux_tendsto_indicator_closure
  {Œ¥seq : ‚Ñï ‚Üí ‚Ñù} (Œ¥seq_lim : tendsto Œ¥seq at_top (ùìù 0)) (E : set Œ±) :
  tendsto (Œª n, (thickened_indicator_aux (Œ¥seq n) E)) at_top
    (ùìù (indicator (closure E) (Œª x, (1 : ‚Ñù‚â•0‚àû)))) :=
begin
  rw tendsto_pi_nhds,
  intro x,
  by_cases x_mem_closure : x ‚àà closure E,
  { simp_rw [thickened_indicator_aux_one_of_mem_closure _ E x_mem_closure],
    rw (show (indicator (closure E) (Œª _, (1 : ‚Ñù‚â•0‚àû))) x = 1,
        by simp only [x_mem_closure, indicator_of_mem]),
    exact tendsto_const_nhds, },
  { rw (show (closure E).indicator (Œª _, (1 : ‚Ñù‚â•0‚àû)) x = 0,
        by simp only [x_mem_closure, indicator_of_not_mem, not_false_iff]),
    rw mem_closure_iff_inf_edist_zero at x_mem_closure,
    obtain ‚ü®Œµ, ‚ü®Œµ_pos, Œµ_le‚ü©‚ü© : ‚àÉ (Œµ : ‚Ñù), 0 < Œµ ‚àß ennreal.of_real Œµ ‚â§ inf_edist x E,
    { by_cases dist_infty : inf_edist x E = ‚àû,
      { rw dist_infty,
        use [1, zero_lt_one, le_top], },
      { use (inf_edist x E).to_real,
        exact ‚ü®(to_real_lt_to_real zero_ne_top dist_infty).mpr (pos_iff_ne_zero.mpr x_mem_closure),
                of_real_to_real_le‚ü©, }, },
    rw metric.tendsto_nhds at Œ¥seq_lim,
    specialize Œ¥seq_lim Œµ Œµ_pos,
    simp only [dist_zero_right, real.norm_eq_abs, eventually_at_top, ge_iff_le] at Œ¥seq_lim,
    rcases Œ¥seq_lim with ‚ü®N, hN‚ü©,
    apply @tendsto_at_top_of_eventually_const _ _ _ _ _ _ _ N,
    intros n n_large,
    have key : x ‚àâ thickening Œµ E, by rwa [thickening, mem_set_of_eq, not_lt],
    refine le_antisymm _ bot_le,
    apply (thickened_indicator_aux_mono (lt_of_abs_lt (hN n n_large)).le E x).trans,
    exact (thickened_indicator_aux_zero Œµ_pos E key).le, },
end

/-- The `Œ¥`-thickened indicator of a set `E` is the function that equals `1` on `E`
and `0` outside a `Œ¥`-thickening of `E` and interpolates (continuously) between
these values using `inf_edist _ E`.

`thickened_indicator` is the (bundled) bounded continuous function with `‚Ñù‚â•0`-values.
See `thickened_indicator_aux` for the unbundled `‚Ñù‚â•0‚àû`-valued function. -/
@[simps] def thickened_indicator {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) : Œ± ‚Üí·µá ‚Ñù‚â•0 :=
{ to_fun := Œª (x : Œ±), (thickened_indicator_aux Œ¥ E x).to_nnreal,
  continuous_to_fun := begin
    apply continuous_on.comp_continuous
            continuous_on_to_nnreal (continuous_thickened_indicator_aux Œ¥_pos E),
    intro x,
    rw mem_set_of_eq,
    apply ne_of_lt,
    exact lt_of_le_of_lt (@thickened_indicator_aux_le_one _ _ Œ¥ E x) one_lt_top,
  end,
  map_bounded' := begin
    use 2,
    intros x y,
    rw [nnreal.dist_eq],
    apply (abs_sub _ _).trans,
    rw [nnreal.abs_eq, nnreal.abs_eq, ‚Üêone_add_one_eq_two],
    have key := @thickened_indicator_aux_le_one _ _ Œ¥ E,
    apply add_le_add;
    { norm_cast,
      refine (to_nnreal_le_to_nnreal ((lt_of_le_of_lt (key _) one_lt_top).ne) one_ne_top).mpr
             (key _), },
  end, }

lemma thickened_indicator.coe_fn_eq_comp {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) :
  ‚áë(thickened_indicator Œ¥_pos E) = ennreal.to_nnreal ‚àò thickened_indicator_aux Œ¥ E := rfl

lemma thickened_indicator_le_one {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) (x : Œ±) :
  thickened_indicator Œ¥_pos E x ‚â§ 1 :=
begin
  rw [thickened_indicator.coe_fn_eq_comp],
  simpa using (to_nnreal_le_to_nnreal thickened_indicator_aux_lt_top.ne one_ne_top).mpr
    (thickened_indicator_aux_le_one Œ¥ E x),
end

lemma thickened_indicator_one_of_mem_closure
  {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) {x : Œ±} (x_mem : x ‚àà closure E) :
  thickened_indicator Œ¥_pos E x = 1 :=
by rw [thickened_indicator_apply,
       thickened_indicator_aux_one_of_mem_closure Œ¥ E x_mem, one_to_nnreal]

lemma thickened_indicator_one {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) {x : Œ±} (x_in_E : x ‚àà E) :
  thickened_indicator Œ¥_pos E x = 1 :=
thickened_indicator_one_of_mem_closure _ _ (subset_closure x_in_E)

lemma thickened_indicator_zero
  {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : set Œ±) {x : Œ±} (x_out : x ‚àâ thickening Œ¥ E) :
  thickened_indicator Œ¥_pos E x = 0 :=
by rw [thickened_indicator_apply, thickened_indicator_aux_zero Œ¥_pos E x_out, zero_to_nnreal]

lemma thickened_indicator_mono {Œ¥‚ÇÅ Œ¥‚ÇÇ : ‚Ñù}
  (Œ¥‚ÇÅ_pos : 0 < Œ¥‚ÇÅ) (Œ¥‚ÇÇ_pos : 0 < Œ¥‚ÇÇ) (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : set Œ±) :
  ‚áë(thickened_indicator Œ¥‚ÇÅ_pos E) ‚â§ thickened_indicator Œ¥‚ÇÇ_pos E :=
begin
  intro x,
  apply (to_nnreal_le_to_nnreal thickened_indicator_aux_lt_top.ne
         thickened_indicator_aux_lt_top.ne).mpr,
  apply thickened_indicator_aux_mono hle,
end

lemma thickened_indicator_subset {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) {E‚ÇÅ E‚ÇÇ : set Œ±} (subset : E‚ÇÅ ‚äÜ E‚ÇÇ) :
  ‚áë(thickened_indicator Œ¥_pos E‚ÇÅ) ‚â§ thickened_indicator Œ¥_pos E‚ÇÇ :=
begin
  intro x,
  exact (to_nnreal_le_to_nnreal thickened_indicator_aux_lt_top.ne
         thickened_indicator_aux_lt_top.ne).mpr (thickened_indicator_aux_subset Œ¥ subset x),
end

lemma thickened_indicator_tendsto_indicator_closure
  {Œ¥seq : ‚Ñï ‚Üí ‚Ñù} (Œ¥seq_pos : ‚àÄ n, 0 < Œ¥seq n) (Œ¥seq_lim : tendsto Œ¥seq at_top (ùìù 0)) (E : set Œ±) :
  tendsto (Œª n, (thickened_indicator (Œ¥seq_pos n) E).to_fun) at_top
    (ùìù (indicator (closure E) (Œª x, (1 : ‚Ñù‚â•0)))) :=
begin
  have key := thickened_indicator_aux_tendsto_indicator_closure Œ¥seq_lim E,
  rw tendsto_pi_nhds at *,
  intro x,
  rw (show indicator (closure E) (Œª x, (1 : ‚Ñù‚â•0)) x
         = (indicator (closure E) (Œª x, (1 : ‚Ñù‚â•0‚àû)) x).to_nnreal,
      by refine (congr_fun (comp_indicator_const 1 ennreal.to_nnreal zero_to_nnreal) x).symm),
  refine tendsto.comp (tendsto_to_nnreal _) (key x),
  by_cases x_mem : x ‚àà closure E; simp [x_mem],
end

end thickened_indicator -- section
